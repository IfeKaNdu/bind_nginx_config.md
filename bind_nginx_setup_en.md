# The  Installation and Configuration of bind and nginx packages on CentOS 7 for LAN

Domain Name System is responsible for translating Internet domain and hostnames to IP addresses and vice versa.DNS Clients will be sending the requests (hostname/IP addresses) to the DNS Server and will await for a response.

### Installation of the BIND DNS server package

Install DNS with all its dependencies.

```bash
# yum install -y bind*
```
-------------------------------------------------------------- 
### Assign A Static IP Address to the DNS Server

###### NOTE: The IP address has to be static and not dynamic so that each time your computer starts or reboots the IP address will remain unchanged.

Configure the `/etc/sysconfig/network-script/ifcfg-* ` file depending on the network interface you want to use. I used a wireless interface that is connected to a wireless HUAWEI DSL Modem.

```bash 
$ sudo vim /etc/sysconfig/network-scripts/ifcfg-HUAWEI-E5336-E71A

HWADDR=**:**:**:**:**:**
ESSID=HUAWEI-E5336-E71A
MODE=Managed
KEY_MGMT=WPA-PSK
MAC_ADDRESS_RANDOMIZATION=default
TYPE=Wireless
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=HUAWEI-E5336-E71A
UUID=c134a4f1-b498-47db-b071-4e7f7679aebd
ONBOOT=yes
IPADDR=192.168.8.2
PREFIX=24
GATEWAY=192.168.8.1
DOMAIN=odii.cic
DNS1=192.168.8.2
DNS2=127.0.0.1
PEERDNS=yes
PEERROUTES=yes

```
Find descriptions of the above networking variables  in the `/usr/share/doc/initscripts*/sysconfig.txt` file.
-------------------------------------------------------------- 
### Assign A FQDN (Fully Qualified Domain Name) For The Server

Edit the `/etc/sysconfig/network` file to add the HOSTNAME of your choice. Mine is `host.odii.cic`
**Note** Since we are configuring a local DNS server, the domain must not stop with .com .This must be avoided inorder not to polute the root servers with queries from a domain that do not exist on the internet.
```bash
# vim /etc/sysconfig/network 
NETWORKING=yes
HOSTNAME=host.odii.cic
-------------------------------------------------------------- ```
###  Configure the `/etc/hosts` file by adding a Host Entry
```bash
# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.8.2    odii.cic
```
Notice in the above,  `192.168.8.2`  and  `odii.cic` were added which will change depending on the static IP and HOSTNAME of your choice.
`127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6 `
The above was generated by default during the operating system installation.
-------------------------------------------------------------- 
### Configure `/etc/resolv.conf`
```bash
# vim /etc/resolv.conf

search odii.cic
nameserver 192.168.8.2
```

Note: The above step will be configured not just on the DNS server Host but on all the DNS Clients on the LAN that will be using the DNS server for name or ip resolving.
-------------------------------------------------------------- 
### Configure the `/etc/named.conf` file 
```bash
# vim /etc/named.conf
...
options {
	listen-on port 53 { 192.168.8.2; }; # Replace with your IP
#	listen-on-v6 port 53 { ::1; };      # Comment out this line just like was done here 
	directory 	"/var/named";
	dump-file 	"/var/named/data/cache_dump.db";
	statistics-file "/var/named/data/named_stats.txt";
	memstatistics-file "/var/named/data/named_mem_stats.txt";
	recursing-file  "/var/named/data/named.recursing";
	secroots-file   "/var/named/data/named.secroots";
	allow-query     { any; };             # Change this from `none` to `any` just like was done here
...
```
Edit the above based on your IP address, comment out the IPv6 line and change allow-query from **none** to **any** .
-------------------------------------------------------------- 
### Configure the `/etc/named.rfc1912.zones` file so as to point to the zones
```bash
# vim /etc/named.rfc1912.zones
...
zone "odii.cic" IN {            # change to your domain name 
	type master;
	file "forward.zone";	   # change the file `forward.zone`
	allow-update { none; };
};

zone "localhost" IN {
	type master;
	file "named.localhost";
	allow-update { none; };
};

zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa" IN {
	type master;
	file "named.loopback";
	allow-update { none; };
};

zone "8.168.192.in-addr.arpa" IN {       # change to the inverse of the network id of your IP address
	type master;
	file "reverse.zone";             # called the file `reverse.zone` yours can be anything
	allow-update { none; };
};

zone "0.in-addr.arpa" IN {
	type master;
	file "named.empty";
	allow-update { none; };
```
The above file is where you will define your zones ie your forward and reverse lookup zones.
The forward zone is `odii.cic` and the reverse zone is `8.168.192` which is the inverse of the network ID of the assigned IP address `192.168.8`
-------------------------------------------------------------- 
### Create and Configure the File for The Forward and Reverse zones

First there is a template file called `named.localhost` that comes with the bind package during the installation, use it as a template to configure the forward.zone and reverse.zone files. 
``` bash 
#  ls /var/named/
chroot	    data     dyndb-ldap    named.ca	named.localhost  reverse.zone
chroot_sdb  dynamic  forward.zone  named.empty	named.loopback	 slaves
```
Now copy the `named.localhost ` file to the `forward.zone` and `reverse.zone` files with the archive (-a) option so as to maintain the date/time stamps and permissions.
```bash 
# cp -a /var/named/named.localhost  /var/named/forward.zone
# cp -a /var/named/named.localhost  /var/named/reverse.zone
```
Now edit the `/var/named/forward.zone` to look like this

```bash
# vim /var/named/forward.zone
$TTL 1D
@	IN SOA	 host.odii.cic.  root.host.odii.cic. (
					0	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H )	; minimum

@	IN 	NS	host.odii.cic.
host	IN	A	192.168.8.2
ifeka	IN	A	192.168.8.2
www	    IN	A	192.168.8.2
mail	IN	A	192.168.8.2
smtp	IN	A	192.168.8.2
smtps	IN	A	192.168.8.2
pop3	IN	A	192.168.8.2
client1	IN	A	192.168.8.1
client3	IN	A	192.168.8.3
client4	IN	A	192.168.8.4
webmail	IN	CNAME	ifeka
ftp	IN	CNAME	ifeka	
@	IN	A	192.168.8.2

```
configure the `/var/named/reverse.zone` to look like this 
```bash 
# vim /var/named/reverse.zone
$ORIGIN	8.168.192.in-addr.arpa.
$TTL 1D
@	IN 	SOA	host.odii.cic.  root.odii.cic. (
					0	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H ); minimum
@	IN	 NS	host.odii.cic.
@	IN	 PTR	odii.cic.
host	IN	 A	192.168.8.2
client1	IN	 A	192.168.8.1
client3	IN	 A	192.168.8.3
client4	IN	 A	192.168.8.4
1	IN	 PTR	client1.odii.cic.
2	IN	 PTR	host.odii.cic.
3	IN	 PTR	client3.odii.cic.
4	IN	 PTR	client4.odii.cic.

```
-------------------------------------------------------------- 
### Change The Group Ownership of The `forward.zone` and `reverse.zone` Files From root to named
```bash
# chgrp named /var/named/forward.zone
# chgrp named /var/named/reverse.zone  
-------------------------------------------------------------- ```
### Restart the DNS named.service
```bash
# systemctl restart named.service
```
To check if the DNS server is being queried properly, run the following `dig`, `host` and `nslookup` commands which will dig for the named service:
```bash
# dig host.odii.cic

; <<>> DiG 9.9.4-RedHat-9.9.4-74.el7_6.2 <<>> host.odii.cic
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 28381
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;host.odii.cic.			IN	A

;; ANSWER SECTION:
host.odii.cic.		86400	IN	A	192.168.8.2

;; AUTHORITY SECTION:
odii.cic.		86400	IN	NS	host.odii.cic.

;; Query time: 26 msec
;; SERVER: 192.168.8.2#53(192.168.8.2)
;; WHEN: Mon Aug 12 02:05:31 GMT 2019
;; MSG SIZE  rcvd: 72

```

Now with the `host` command
```bash
# host host.odii.cic
host.odii.cic has address 192.168.8.2
```
Now with the `nslookup` command 

```bash
# nslookup odii.cic

Server:		192.168.8.2
Address:	192.168.8.2#53

Name:	odii.cic
Address: 192.168.8.2
```

```bash
# nslookup www.odii.cic
Server:		192.168.8.2
Address:	192.168.8.2#53

Name:	www.odii.cic
Address: 192.168.8.2
```
```bash
# nslookup ftp.odii.cic
Server:		192.168.8.2
Address:	192.168.8.2#53

ftp.odii.cic	canonical name = ifeka.odii.cic.
Name:	ifeka.odii.cic
Address: 192.168.8.2
```
```bash
# hostname
odii.cic
```

The host and dig commands are only used to query DNS servers .They don't check the nsswitch.conf file to find other places to query ,such as the local hosts file.For that, i would have to use the getent command to find a host named odii.cic that was entered into my local `/etc/hosts` file
```bash
# getent hosts
127.0.0.1       localhost localhost.localdomain localhost4 localhost4.localdomain4
127.0.0.1       localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.8.2     odii.cic
```


The above shows that the DNS is being queried properly having being able to resolve the names to IP.


-------------------------------------------------------------- 
### The installation and configuraton of Nginx 

**Note**: The following important steps should be done if Nginx is to be installed on a CentOS that has the default web server Apache for most distributions already running without having to uninstall the Apache before the installation of Nginx.
+ Change Apache default port 80 to a custom port.
+ Disable Apache from starting during the system boot.
+ Mask Apache from ever running. 
-------------------------------------------------------------- 
#### Change Apache default port 80 to a custom port
Configure the Apache httpd service to listen on a port different from port 80 for instance port 8090 inorder to reserve port 80 for the Nginx service.Open the configuration file `/etc/httpd/conf/httpd.conf` then change port 80 to port 8090:
```bash
# vim /etc/httpd/conf/httpd.conf
...
Listen 8090
...
```
To allow port 8090 via firewall, the following steps should be done.
```bash 
$ sudo firewall-cmd --permanent --add-port=8090/tcp
```
To apply the above changes inorder for Apache to bind on the new port 8090, restart the httpd daemon and check the local sockets table using `netstat` command.
Restart Apache web server
```bash
# systemctl restart httpd.service 
```
Add SeLinux rules for port 8090
```bash
# semanage port -a -t http_port_t -p tcp 8090
# semanage port -m -t http_port_t -p tcp 8090
```

Verify that the new port 8090 successfully binds and listens for incoming traffic with the command `netstat`
```bash
# netstat -tupln | grep httpd
tcp        0      0 :::8090              :::*               LISTEN      14682/httpd 
tcp6       0      0 :::8090             :::*                LISTEN      14682/httpd
```
Open a browser and navigate to the server IP address or domain name on port 8090 to verify if the new 8090 is reachable in the network.The Apache default page should be displayed in the browser
```bash
http://192.168.8.2:8090
http://host.odii.cic:8090
-------------------------------------------------------------- ```
### Disable Apache from starting at boot with systemd Initialization Daemon
To disable Apache from starting at boot run the command:
```bash 
# systemctl disable httpd.service
```
However, it does not immediately stop the service. The stop option of systemctl has to be used for it to stop immediately if it is presently running.
```bash
# systemctl stop httpd.service
```
With the above steps, Apache has been disabled and will not start during boot on its own.Sometimes disabling a service is not enough to make sure that it does not run since if some other service listed httpd as a dependency,that service would try to start httpd when it started

To disable httpd in a way that prevents it from ever running on the system,use the mask option.For httpd service never to run, type the following:
```bash
# systemctl mask httpd.service
Created symlink from /etc/systemd/system/httpd.service to /dev/null.
```
As the output shows, the httpd.service file in /etc is linked to /dev/null.So even if someone tried to run that httpd service,nothing would happen. To be able to use httpd again,type 
```bash
# systemctl unmask httpd.service
```
Thus with the above steps the Nginx web server can be installed simultaneously with Apache on the same CentOS server without having to uninstall Apache for the Nginx.

**Note** The two webservers can be configured to run at the same time with one serving as a proxy for the other.
-------------------------------------------------------------- 
### Install Nginx Web Server
First update the system software packages to the latest version.
```bash
# yum -y update
```
 Next, install Nginx HTTP server from the EPEL repository using the YUM package manager as follows:
 ```bash
# yum install epel-release
# yum install nginx 
```
Once Nginx web server is installed, you can start it first time and enable it to start automatically at system boot since the Apache has been disabled
```bash
# systemctl start nginx
# systemctl enable nginx
# systemctl status nginx
```
By default, CentOS 7 built-in firewall is set to block Nginx traffic. To allow web traffic on Nginx, update the system firewall rules to permit inbound packets on HTTP and HTTPS using the commands below.
```bash
# firewall-cmd --zone=public --permanent --add-service=http
# firewall-cmd --zone=public --permanent --add-service=https
# firewall-cmd --reload
```
Verify that the Nginx server is properly in operation after the installation by going to the URL that is configured as the hostname or IP.
```bash
http://host.odii.cic
http://192.168.8.2
```
A default Nginx page will be shown.


-------------------------------------------------------------- 
### Configure nginx to server a website
Beside hosting a static site with nginx, it can still be used to set up reverse proxies and load balancing.Still using the domain name host.odii.cic and the ip address 192.168.8.2 we will point them to the new nginx server.
All nginx configuration files are located in the `/etc/nginx/` directory. The primary configuration file is `/etc/nginx/nginx.conf`.
Configuration options in nginx are called directives. Directives are organized into groups known as blocks or contexts. The two terms are synonymous.
Lines containing directives must end with a ; or nginx will fail to load the configuration and report an error.
Nginx expects the static files to be in a specific directory which can also vary depending on the choice made in the configuration.
Create a directory `/var/www/odii.cic/` where the files can go.Then copy the website's static files into the folder.
```bash
# mkdir /var/www/odii.cic/
# cp -r /home/egbuniwe/Documents/_repo/chrome_extension_welcome  /var/www/odii.cic/
```
Now to the nginx configuration proper, we have to tell nginx about the site and how to serve it.lets create a `*.conf` file in the `/etc/nginx/conf.d/` directory.Inside the file ,fill in the configuration based on your setting.
**NB**:The file mush end with `*.conf`
```bash
# vim /etc/nginx/conf.d/default.conf
```
Inside the file set up the following server block:
```
server {
        listen       80;
        listen       [::]:80;
        server_name  www.odii.cic host.odii.cic odii.cic;
	location / {
             root /var/www/odii.cic/chrome_extension_welcome;
           index index.html index.htm;
        }
         error_page 404 /404.html;
 51             location = /40x.html {
 52         }
     }
``` 
This configuration serves static files over HTTP on port 80 from the directory `/var/www/odii.cic/chrome_extension_welcome`.This it does by telling nginx things such as:
+ Deliver files from the folder `/var/www/odii.cic/chrome_extension_welcome`
+ The main index page is `index.html`.
+ The server_name directive defines the hostname or names of which requests should be directed to this server. It allows a multiple domains to be served from a single IP address.192.168.8.2 will serve requests for www.odii.cic, host.odii.cic and odii.cic from the same location `/var/www/odii.cic/chrome_extension_welcome` .
+ The `location` setting lets you configure how nginx will respond to requests for resources within the server. Just like the `server_name` directive tells nginx how to process requests for the domain, location directives cover requests for specific files and folders based on the path in the URL.
The path, or portion of the URL after the domain, is referred to as the URI.
+ If multiple files are specified for the index directive, nginx will process the list in order and fulfill the request with the first file that exists. If index.html doesn’t exist in the relevant directory, then index.htm will be used. If neither exists, a 404 message will be sent.

check if the configuration is successful by reloading the configuration without stopping the server hence providing the ability to change configurations on the fly without dropping any packets.Restart the nginx server to effect the changes.
```bash
# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

# systemctl restart nginx
```
If it gives you an error, there’s likely a syntax error. Check through the error and access log files 
```bash
# vim /var/log/nginx/access.log;
# vim /var/log/nginx/error.log;
```
Test if the entire Domain names are all working and if nginx is propering serving the website at the root `/var/www/odii.cic/chrome_extension_welcome` by typing the domain names at the browser.
```
+ http://odii.cic
+ http://host.odii.cic
+ http://www.odii.cic
```
The site in the nginx custom configuration file was well rendered by the browser.

### Disabling logging.
Writting web logs takes resources.If your server is now operational, you may want to save resources for your server by disable logging .To do so,open up the main nginx configuration file:
```bash
# vim /etc/nginx/nginx.conf
---
##
# Logging Settings
##
access_log /var/log/nginx/access.log;
error_log /var/log/nginx/error.log;
---
```
Comment out the access_log and the error_log.
```
##
# Logging Settings
##
#access_log /var/log/nginx/access.log;
#error_log /var/log/nginx/error.log;
```					
With the above logging will be disable for your nginx web server.

### Client Side Caching
Telling your clients to cache resources like js, css, and images files can significantly improve performance.
Add the following caching rules to the end of the your server block:
```
---
 # Media: images, icons, video, audio, HTC
	    location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|mp4|ogg|ogv|webm|htc)$ {
	      access_log off;
	      add_header Cache-Control "max-age=2592000";
	    }	    # CSS and Javascript
	    location ~* \.(?:css|js)$ {
	      add_header Cache-Control "max-age=31536000";
	      access_log off;
	    }
```
The server block should now look like this:
```
server {
        listen       80;
        listen       [::]:80;
        server_name  www.odii.cic host.odii.cic odii.cic;
	location / {
             root /var/www/odii.cic/chrome_extension_welcome;
           index index.html index.htm;
        }
         error_page 404 /404.html;
 51             location = /40x.html {
 52         }
	 # Media: images, icons, video, audio, HTC
	    location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|mp4|ogg|ogv|webm|htc)$ {
	      access_log off;
	      add_header Cache-Control "max-age=2592000";
	    }	    # CSS and Javascript
	    location ~* \.(?:css|js)$ {
	      add_header Cache-Control "max-age=31536000";
	      access_log off;
	    }

    }
###								References
		
+ Negus, N.  2015: Linux Bible(9th edition). Indianapolis, Indiana: John Wiley & Sons Inc., pp. 187,355-358, 362-375,449-476,576-577,708-713.

+ Derek, D.  2019: Nginx Cookbook(2019 update). 1005 Gravenstein Highway North, Sebastopol,CA : O’Reilly Media, Inc., pp. 1-8.3

+ 2019, [BIND 9 Administrator Reference Manual BIND 9.14.4 (Stable Release](https://downloads.isc.org/isc/bind9/cur/9.14/doc/arm/Bv9ARM.pdf (accessed August 6,2019)) .

+ 2019, [System Administrator's Guide ](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/index (accessed August 7,2019)) .

+ 1987, [DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION ](https://tools.ietf.org/html/rfc1035 (accessed August 7,2019)) .

+ 1987, [DOMAIN NAMES - CONCEPTS AND FACILITIES ](https://tools.ietf.org/html/rfc1034 (accessed August 7,2019)) .

+ 2013, [Introduction to DNS (Domain Name Services) ](https://www.youtube.com/watch?v=VwpP8PUzqLw (accessed August 6,2019)) .

+ 2018, [Linux Administration Tutorial - Configuring A DNS Server In 10 Simple Steps | Edureka Live  ](https://www.youtube.com/watch?v=0X9em99Vcl0&t=7s (accessed August 6,2019)) .

+ 2014, [Setting Up DNS Server On CentOS 7](https://www.unixmen.com/setting-dns-server-centos-7/ (accessed August 7,2019)) .
 
+ 2018, [How to configure DNS Name Server in Centos7 , Redhat7 (Server and Client Configuration)) ](https://www.youtube.com/watch?v=is-eg2X5ru4&t=2s (accessed August 6,2019)) .

+ 2017, [How to Install Nginx on CentOS 7](https://www.tecmint.com/install-nginx-on-centos-7/ (accessed August 11,2019)) .
 
+ 2016, [How To Change Apache Default Port To A Custom Port ](https://www.ostechnix.com/how-to-change-apache-ftp-and-ssh-default-port-to-a-custom-port-part-1/ (accessed August 10,2019)) .

+ 2012, [Install & Configure BIND DNS Server in CentOS - Part 3 ](https://www.youtube.com/watch?v=70aVLHzbMzw&t=17s (accessed August 10,2019)) .

+ 2017, [A guide to hosting static websites using NGINX ](https://medium.com/@jgefroh/a-guide-to-using-nginx-for-static-websites-d96a9d034940 (accessed August 20,2019)) .

+ 2018, [How to Host a Static Website with Nginx ](https://medium.com/@jasonrigden/how-to-host-a-static-website-with-nginx-8b2dd0c5b301 (accessed August 20,2019)) .



